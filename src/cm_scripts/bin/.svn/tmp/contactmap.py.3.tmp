#! /usr/bin/env python
# A simple utility for generating contact maps from a collection
# of models. Native features are annotated with boxes in the output.
# It is the caller's responsibility to ensure that the number of
# residues match.
#
# Requires BioPython (biopython.org), numpy (numpy.scipy.org),
# and gnuplot (gnuplot.info).
#
# @author Christopher Miles (cmiles@uw.edu)
import argparse, os, os.path, subprocess, tempfile
import Bio.PDB, numpy

class Contact:
    '''Simple container for storing information about a contact'''
    def __init__(self, resi, resj, dist):
        self.resi = resi
        self.resj = resj
        self.dist = dist

    def __str__(self):
        return '%d %d %f' % (self.resi, self.resj, self.dist)

    def residue1(self):
        return self.resi

    def residue2(self):
        return self.resj

    def distance(self):
        return self.dist

def count_residues(filename):
    '''Returns the number of residues in filename'''
    assert os.path.exists(filename)
    structures = Bio.PDB.PDBParser().get_structure('', filename)
    model = structures[0]
    return len(list(model.get_residues()))

def contacts(filename, num_residues, atom, separation, distance):
    '''Returns a list of contacts for the given atom type, sequence separation, and distance'''
    assert os.path.exists(filename)
    assert separation >= 0
    assert distance >= 0.0

    structures = Bio.PDB.PDBParser().get_structure('', filename)
    model = structures[0]

    residues = list(model.get_residues())[:num_residues]
    for i in range(0, len(residues)):
        resi = i + 1
        ai = residues[i][atom]

        for j in range(i + 1, len(residues)):
            resj = j + 1
            aj = residues[j][atom]

            # contact sequence separtion, distance
            con_separation = abs(resi - resj)
            con_distance = ai - aj

            if con_separation >= separation and con_distance <= distance:
                yield Contact(resi, resj, con_distance)

def contacts_from_contactFile(filename):
    '''Returns a list of contacts and percentage'''
    assert os.path.exists(filename)
    with open(filename) as fin:
        for line in fin:
            position = line.split()
            resi = int(position[0])
            resj = int(position[1])
            c=Contact(resi,resj,-1)
            print c
            yield c


def write_contact_file(filename, counts):
    with open(filename, 'w') as file:
        for i in range(1, len(counts)):
            for j in range(i + 1, len(counts)):
                if counts[i][j] > 0:
                    file.write('%d %d %d\n' % (i, j, counts[i][j]))

def plot(output_filename, num_residues, counts, native_counts = None):
    (handle, counts_filename) = tempfile.mkstemp()
    write_contact_file(counts_filename, counts)

    native_filename = None
    if native_counts != None:
        (handle, native_filename) = tempfile.mkstemp()
        write_contact_file(native_filename, native_counts)

    scale = 100 * num_residues ** -1.123

    (handle, plot_filename) = tempfile.mkstemp()
    with open(plot_filename, 'w') as file:
        file.write("set term postscript color solid\n")
        file.write("set output '%s'\n" % output_filename)
        file.write("set size square\n")
        file.write("set size ratio -1\n")
        file.write("set palette rgbformulae 22, 13, -31\n")

        if native_counts == None:
            file.write("plot [][] '%s' u 1:2:3 w p pt 5 ps %s palette not\n" % (counts_filename, scale))
        else:
            file.write("plot [][] '%s' u 1:2:3 w p pt 5 ps %s palette not, '%s' u 1:2 w p pt 4 ps %s lt 0 not\n" % (counts_filename, scale, native_filename, scale))

    subprocess.check_output(['gnuplot', plot_filename])
    subprocess.check_output(['ps2pdf', output_filename])

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--models', '-m', nargs = '+', help = 'Models to analyze')
    parser.add_argument('--counts', '-c', help = 'ct1 ct2 pct, requires native, replaces models')
    parser.add_argument('--native', '-n', help = 'Native structure')
    parser.add_argument('--atom', '-a', default = 'CA', help = 'Atom used to compute distances')
    parser.add_argument('--distance', '-d', type = float, default = 8.0, help = 'Maximum distance between contacts')
    parser.add_argument('--separation', '-s', type = int, default = 0, help = 'Minimum sequence separation between contacts')
    parser.add_argument('--filename', '-f', default = 'plot', help = 'Output filename')
    options = vars(parser.parse_args())

    # Assumes identical sequences
    num_residues = 0
    if options['counts']:
        num_residues = count_residues(options['native'])
    else:
        num_residues = count_residues(options['models'][0])
    counts = numpy.zeros((num_residues + 1, num_residues + 1), dtype = numpy.int32)

    # Contacts from models
<<<<<<< .mine
    if options['counts']:
        for c in contacts_from_contactFile(options['counts']):
=======
    for m in options['models']:
        for c in contacts(m, num_residues, options['atom'], options['separation'], options['distance']):
>>>>>>> .r48748
            counts[c.residue1()][c.residue2()] += 1
            counts[c.residue2()][c.residue1()] += 1
    else:
        for m in options['models']:
            for c in contacts(m, options['atom'], options['separation'], options['distance']):
                counts[c.residue1()][c.residue2()] += 1
                counts[c.residue2()][c.residue1()] += 1

    # Contacts from native
    native_counts = numpy.zeros((num_residues + 1, num_residues + 1), dtype = numpy.int32) if options['native'] else None
    if options['native']:
        for c in contacts(options['native'], num_residues, options['atom'], options['separation'], options['distance']):
            native_counts[c.residue1()][c.residue2()] += 1
            native_counts[c.residue2()][c.residue1()] += 1

    plot(options['filename'], num_residues, counts, native_counts)

