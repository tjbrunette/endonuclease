#!/usr/bin/perl

use strict;
use warnings;

use Cwd qw/ abs_path /;
use FindBin;
use Getopt::Long;
use File::Copy;
use File::Path;
use File::Basename;

use lib "$FindBin::Bin/../perl_lib";
use Rosetta::Job;
use Rosetta::Util;
use Rosetta::Instance;

my %options;
$options{dir}         = "run"; # $ENV{PWD};
$options{scratch_dir} = assemble_path( $ENV{PWD}, 'scratch' );
$options{nstruct}     = 5;
$options{compiler}    = 'gcc';
$options{extra_args}  = 0;
$options{lockfile}    = 'run.lock';
$options{db}          = "/work/cmiles/src/rosetta/rosetta_database";
$options{mini_prefix} = "/work/cmiles/src/rosetta/rosetta_source/bin";
$options{executable}  = 0;
&GetOptions(
	\%options,
	"dir=s",
	"nstruct=i",
	"compiler=s",
	"extra_args=s",
	"scratch_dir=s",
	"lockfile=s",
	"db=s",
	"mini_prefix=s",
);

# takes a boinc submit file, runs it on the digs
my $boinc_submit_fn = $ARGV[0];
if ( ! $boinc_submit_fn || !-f $boinc_submit_fn ) {
	die "Error: must provide a boinc submit file as first argument!\n";
}

my $dat = parse_boinc_submit( $boinc_submit_fn );

my $application = $dat->{application};
my $inputfiles  = $dat->{inputfiles};

if ( $application ne 'minirosetta' ) {
	die "Error: don't recognize application $application!\n";
}

if ( ! -d $options{dir} ) {
	mkpath $options{dir};
}

# unzip all of the inputfiles into the directory if they are named .zip or
# .tar.gz
mkdir_recursive($options{scratch_dir});
my $scratch_lockfile = assemble_path(
	$options{scratch_dir}, 'create_files.lock'
);
if ( ! -f $scratch_lockfile ) {
	system( "touch $scratch_lockfile" );
	foreach my $fn (@$inputfiles) {
		print "examining $fn\n";

		if ( ! -f $fn ) {
			my $dir = dirname($boinc_submit_fn);
			$fn = assemble_path($dir, basename($fn));
			if ( ! -f $fn ) {
				die "Error: filename $fn doesn't exist!";
			}
		}
		copy( $fn, $options{scratch_dir} );

		if ( $fn =~ /\.zip$/ ) {
			$fn = basename $fn;
			# -n => never overwrite
			system( "cd $options{scratch_dir}; unzip -n $fn" );
		}
	 	if ( $fn =~ /\.tar(\.gz|\.bz2)$/ ) {
			$fn = basename $fn;
			my $suffix = $1;
			# x => extract
			# k => keep existing files, don't overwrite them
			# v => extract things verbosely
			# f => use the provided filename
			my $tar_flags = "xkvf";
			if ( $suffix eq 'gz' ) {
				# z => use gzip compression
				$tar_flags .= "z";
			} elsif ( $suffix eq 'bz2' ) {
				# j => use bzip2 compression
				$tar_flags .= "j";
			}
			system( "cd $options{scratch_dir}; tar $tar_flags $fn" );
		}
	}
}
# don't unlink $scratch_lockfile to save time running other jobs.
# unlink $scratch_lockfile;

# make symlinks from scratch_dir
$options{scratch_dir} = abs_path($options{scratch_dir});
my $cmd = "cd $options{dir}; ln -s $options{scratch_dir}/* .";
print $cmd, "\n";
system($cmd);

# run the command
my $args = $dat->{arguments};
$args = join ' ', (
	$args,
	'-nstruct', $options{nstruct},
	'-shuffle_nstruct', $options{nstruct},
	'-database', $options{db},
);

my $instance = Rosetta::Instance->new(
	mode        => 'release',
	compiler    => $options{compiler},
	mini_prefix => $options{mini_prefix},
);
my $job = $instance->generate_job( $application, $args );
if ( $options{executable} ) {
	$job->executable( $options{executable} );
}
$job->dir( $options{dir} );
$job->lockfile( $options{lockfile} );
$job->results_file( "" );
if ( $options{extra_args} ) {
	#print "adding extra arguments: $options{extra_args}\n";
	$job->add_args( $options{extra_args} );
}
print $job->to_string, "\n";
$job->run( "running $application in $options{dir}" );

sub print_options {
	my $hashref = shift;

	foreach my $key ( sort keys %$hashref ) {
		print join ': ', ( $key, $hashref->{$key} );
		print "\n";
	}
}

sub parse_boinc_submit {
	my $fn = shift;

	my %data;
	open FILE, "<$fn" or die $!;
	while ( my $line = <FILE> ) {
		if ( $line =~ /^(.*)\s*=\s*(.*)$/ ) {
			my $key = $1;
			my $val = $2;

			$key = trim_whitespace( $key );
			$val = trim_whitespace( $val );

			my @d = split /,/, $val;
			if ( scalar(@d) > 1 ) {
				$data{$key} = \@d	;
			} else {
				$data{$key} = $val;
			}
		}
	}

	return \%data;
}
