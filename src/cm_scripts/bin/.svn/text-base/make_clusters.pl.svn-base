#!/usr/bin/perl

use strict;
use warnings;

$|++;

use lib '/work/tex/src/cm_scripts/perl_lib';

use Cwd;
use Getopt::Long;
use File::Copy;
use File::Path;
use List::Util qw/ sum min max /;
use File::Basename;
use Data::Dumper::Simple;
use Rosetta::PDB qw/ pdb_to_seq /;
use Rosetta::align_util qw/ read_alns /;
use TMalign qw/ get_tmscore /;

use constant MIN_TMSCORE => 0.8; # minimum two partial threads to be clustered together

my @targets = map { "T0$_" } ( 515 .. 643 );
my $cluster_base = "/work/brunette/experiments/casp9_reruns/local_alignments/clustered_all";
if (@ARGV) { @targets = @ARGV; }

my $orig_dir = getcwd;
TARGET: foreach my $target (@targets) {
	my $working_dir = $target;
	#if ( -d $working_dir ) { next; }
	mkpath $working_dir;
	chdir($working_dir);

	my $aln_fn   = "$cluster_base/$target/alignment/alignment.filt";
	my $fasta_fn = "$cluster_base/$target/alignment/t000_.fasta";
	my $native   = "/work/tex/casp9_benchmark/natives/$target.pdb";
	my @partial_threads = glob( "$cluster_base/$target/alignment/*.pdb" );

	if ( !-f $native )   { next; }
	if ( !-f $fasta_fn ) { next; }
	if ( !-f $aln_fn )   { next; }
	if ( scalar(@partial_threads) == 0 ) { next; }

	my $seq_len  = length(pdb_to_seq($fasta_fn));
	my @alns     = read_alns($aln_fn,'grishin');

	print "making clusters for $target.\n";

	my %tmscores; # relative to native
	foreach my $pdb (@partial_threads) {
		$tmscores{basename($pdb)} = get_tmscore($pdb,$native,$seq_len);
	}

	my %sims;
	my $sim_fn = "sims.txt";
	if ( -f $sim_fn ) {
		%sims = read_sims($sim_fn);
	} else {
		my $total_sims = (scalar(@partial_threads) ** 2 - scalar(@partial_threads));
		my $n_done = 0;
		foreach my $idx1 (0 .. scalar(@partial_threads)-1) {
		foreach my $idx2 ($idx1 + 1 .. scalar(@partial_threads)-1) {
			my $pdb1 = $partial_threads[$idx1];
			my $pdb2 = $partial_threads[$idx2];
			my $tmscore = get_tmscore($pdb1,$pdb2,$seq_len);
			my $id1 = basename($pdb1);
			my $id2 = basename($pdb2);

			$sims{$id1}{$id2} = $tmscore;
			$sims{$id2}{$id1} = $tmscore;
			$n_done++;
			if ( $n_done % 10 == 0 ) {
				print "finished with $n_done/$total_sims comparisons.\n";
			}
		}
		}
		print "finished computing sims for $target.\n";
		write_sims(\%sims,$sim_fn);
	}

	my @clusters;
	my $threshold = 0.7;

	my $finished = 0;
	while ( !$finished ) {
		@clusters = ();
		foreach my $pdb (@partial_threads) {
			push @clusters, [ basename($pdb) ];
		}
		@clusters = make_clusters( \@clusters, \%sims, $threshold );
		my $biggest_cluster_size = scalar( @{$clusters[0]} );

		my $pct = sprintf( "%4.3f", 100 * $biggest_cluster_size / scalar(@partial_threads) );
		print "biggest has $pct% of the models (threshold = $threshold).\n";

		if ( $pct > 50 ) {
			$threshold += 0.01;
			$finished = 0;
		} elsif ( $pct < 20 ) {
			$threshold -= 0.01;
			$finished = 0;
		} else {
			print "finished with pct = $pct and threshold = $threshold.\n";
			$finished = 1;
		}

		if ( $threshold > 0.95 || $threshold < 0.2 ) {
			$finished = 1;
		}
	}

	open LOG, ">cluster_summary.txt" or die $!;
	print LOG join ' ', qw/ cluster avg_sim n_members best_tmscore worst_tmscore /;
	print LOG "\n";
	foreach my $idx ( 0 .. scalar(@clusters)-1 ) {
		my $cluster = $clusters[$idx];

		my @sims;
		my $best_tmscore  = max( map { $tmscores{$_} } @$cluster );
		my $worst_tmscore = min( map { $tmscores{$_} } @$cluster );
		foreach my $ii ( 0 .. scalar(@$cluster)-1 ) {
			my $model_name = $cluster->[$ii];
			foreach my $jj ( $ii+1 .. scalar(@$cluster)-1 ) {
				push @sims, $sims{$cluster->[$ii]}{$cluster->[$jj]};
			}
		}
		my $avg_sim   = mean(@sims);
		my $n_members = scalar(@$cluster);
		print LOG join ' ', ( $idx, $avg_sim, $n_members, $best_tmscore, $worst_tmscore );
		print LOG "\n";
	}
	close LOG or die $!;

	# print out members for each cluster
	my %indexed_alns;
	foreach my $aln (@alns) {
		$indexed_alns{$aln->template_name} = $aln;
	}
	open LOG, ">members.txt" or die $!;
	foreach my $idx ( 0 .. scalar(@clusters)-1 ) {
		print LOG join ' ', ( $idx, @{$clusters[$idx]} );
		print LOG "\n";

		open FILE, ">$target.cluster$idx.filt";
		foreach my $member (@{$clusters[$idx]}) {
			my $id = basename($member,'.pdb');
			#print "assigning $id -> cluster$idx\n";
			my $aln = $indexed_alns{$id};
			if ( !defined $aln ) {
				print Dumper(%indexed_alns);
				die "No alignment by name $id!\n";
			}
			print FILE $aln->filt_string, "\n";
		}
		close FILE or die $!;

		# superposition
		my $pdb_str = join ' ', map { "$cluster_base/$target/alignment/$_" } @{$clusters[$idx]};
		my $cmd = "superimpose.py $pdb_str > super$idx.pdb";
		my $output = `$cmd`;
	}
	close LOG or die $!;
	chdir($orig_dir);
}

sub compute_sim {
	my $c1 = shift;
	my $c2 = shift;
	my $sims = shift;

	my @sims;
	foreach my $m1 (@$c1) {
	foreach my $m2 (@$c2) {
		my $sim = $sims->{$m1}{$m2};
		if ( !defined $sim ) {
			print Dumper($sims);
			print Dumper($sim);
			die "sim not defined for $m1,$m2\n";
		}
		push @sims, $sim;
	}
	}

	return max(@sims);
}

sub mean {
	my $mean = 0;
	foreach my $n (@_) {
		$mean += $n/scalar(@_);
	}
	return $mean;
}

sub write_sims {
	my $sims = shift;
	my $fn   = shift;

	if ( -f $fn ) { return; }

	open WRITE, ">$fn" or die $!;
	foreach my $key1 ( keys %$sims ) {
	foreach my $key2 ( keys %{$sims->{$key1}} ) {
		print WRITE join ' ', ( $key1, $key2, $sims->{$key1}{$key2} );
		print WRITE "\n";
	}
	}
	close WRITE or die $!;
}

sub read_sims {
	my $fn = shift;

	if ( ! -f $fn ) { die "Error: file $fn doesn't exist!\n"; }

	my %data;
	open FILE, "<$fn" or die $!;
	while ( my $line = <FILE> ) {
		chomp $line;
		my ($key1,$key2,$sim) = split /\s+/, $line;
		$data{$key1}{$key2} = $sim;
	}
	close FILE or die $!;

	if ( wantarray ) { return %data; }
	return \%data;
}

sub make_clusters {
	my $initial_clusters = shift;
	my $local_sims       = shift;
	my $threshold        = shift;

	# begin merging clusters (O(n))
	my @clusters = @$initial_clusters;;

	CLUSTERING: while (1) {
		# find the maximum average similarity between two clusters
		my $max_sim   = 0;
		my $best_pair = [-1,-1];
		foreach my $idx1 ( 0 .. scalar(@clusters)-1 ) {
		foreach my $idx2 ( $idx1+1 .. scalar(@clusters)-1 ) {
			my $c1 = $clusters[$idx1];
			my $c2 = $clusters[$idx2];

			my $sim = compute_sim( $c1, $c2, $local_sims );

			if ( $sim > $max_sim ) {
				$max_sim   = $sim;
				$best_pair = [$idx1, $idx2];
			}
		}
		}

		if ( scalar(@clusters) == 1 || $max_sim <= $threshold ) {
			#print "stopping with ", scalar(@clusters), " clusters ",
			#	"and a max_sim of $max_sim (threshold = $threshold)\n";
			last CLUSTERING;
		} else {
			# merge the clusters with the minimum distance
			#print "merge ", $best_pair->[0], ' ', $best_pair->[1], " with sim of $max_sim (threshold = $threshold)\n";
			foreach my $m ( @{$clusters[$best_pair->[1]]} ) {
				push @{$clusters[$best_pair->[0]]}, $m;
			}
			delete $clusters[ $best_pair->[1] ];
			@clusters = grep { defined } @clusters;
		}
	}

	@clusters = sort { scalar(@$b) <=> scalar(@$a) } @clusters;
	if ( wantarray ) { return @clusters; }
	return \@clusters;
}
