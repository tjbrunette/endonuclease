#!/usr/bin/perl

use strict;
use warnings;

$|++;

use List::Util qw/ max /;

my $header = <>;
my @data;
my @column_names = split /\s+/, $header;
while ( my $line = <> ) {
	chomp $line;
	my @d = split /\s+/, $line;

	push @data, data_to_hashref(\@d,\@column_names);
}

my %formats;
my @formatted_column_names;
foreach my $col (@column_names) {
	my @vals   = map { $_->{$col} } @data;
	my $format = guess_format(\@vals);
	my $width  = max( map { smart_length($_) } ($col,@vals) );

	my $format_str = '%' . $width . 's';
	if ( $format eq 'digit' ) {
		$format_str = '%' . $width . 'd';
	} elsif ( $format eq 'float' ) {
		$format_str = '%' . $width . '.' . '3f';
	}
	$formats{$col} = $format_str;
	push @formatted_column_names, sprintf( '%' . $width . 's', $col );
}

print join ' ', @formatted_column_names;
print "\n";
foreach my $d (@data) {
	my @output_tokens;
	foreach my $col (@column_names) {
		push @output_tokens, sprintf( $formats{$col}, $d->{$col} );
	}

	print join ' ', (@output_tokens);
	print "\n";
}

sub guess_format {
	my $vals = shift;

	my %counts;
	foreach my $v (@$vals) {
		if ( is_digit($v) ) {
			$counts{digit}++;
		} elsif ( is_float($v) ) {
			$counts{float}++;
		} else {
			$counts{string}++;
		}
	}

	# upgrade digit => float if necessary
	if ( exists $counts{digit} && exists $counts{float} ) {
		delete $counts{digit};
	}

	my @valid_formats = keys %counts;
	if ( scalar(@valid_formats) > 1 ) {
		print join ' ', @$vals;
		print "\n";
		foreach my $format ( keys %counts ) {
			print join ' ', ( $format, $counts{$format} );
			print "\n";
		}
		die "Error: too many formats!\n";
	}

	my $format = $valid_formats[0];

	return $format;
}

sub is_digit {
	my $v = shift;
	$v =~ s/\s+//g;
	return ( $v =~ /^\d+$/ );
}

sub is_float {
	my $v = shift;
	$v =~ s/\s+//g;
	return ( $v =~ /^\-?\d+\.*\d+$/ );
}

sub data_to_hashref {
	my $d = shift;
	my $c = shift;

	if ( scalar(@$d) != scalar(@$c) ) {
		die "Column mismatch!\n";
	}

	my $hashref = {};
	foreach my $idx ( 0 .. scalar(@$d) - 1 ) {
		$hashref->{ $c->[$idx] } = $d->[$idx];
	}

	return $hashref;
}

# wrapper around perl's length function that truncates
# unnecessary precision from floating point numbers
sub smart_length {
	my $str = shift;

	use constant pad => 4;
	if ( $str =~ /^([-+]?[0-9]*\.[0-9]+|[0-9]+)$/ ) {
		my $num = $1;
		my ($rhs,$lhs) = split /\./, $num;
		return length($rhs)+pad;
	}
	return length($str);
}
