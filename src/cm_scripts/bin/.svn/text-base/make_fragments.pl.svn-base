#!/usr/bin/perl

use strict;
use warnings;

use File::Path;
use File::Copy qw/ copy /;
use File::Basename;
use Sys::Hostname;
my $host = hostname;
###############################################################################
# USER CONFIGURATION  -- ONLY CHANGE THIS SECTION.
#                        YOU MUST EDIT THESE PATHS BEFORE USING
###############################################################################

# change the following paths to point to the locations of your copies of these
# files, databases or directories.

# shareware_dir
my $src_dir       = "/work/robetta/src";
my $shareware_dir = "$src_dir/shareware";

# psi-blast
my $PSIBLAST      = "$shareware_dir/blast/blastpgp -a 8";

my $NR            = "/work/robetta/src/mini_fragpicker/databases/casp9/2010-05-21/nr";
my $VALL_BLAST_DB = "/work/robetta/src/mini_fragpicker/databases/casp9/vall.blast.apr24";
my $PDB_DB        = "/work/robetta/src/mini_fragpicker/databases/casp9/2010-07-15/pdb/pdb_seqres.txt";

my $BLOSUM_PATH   = "$src_dir/mini_fragpicker";

# psipred
my $FILTNR        = "/work/robetta/src/mini_fragpicker/databases/casp9/2010-05-21/nr";
my $MAKEMAT       = "$shareware_dir/blast/makemat";
my $PSIPRED       = "$shareware_dir/psipred/bin/psipred";
my $PSIPASS2      = "$shareware_dir/psipred/bin/psipass2";
my $PSIPRED_DATA  = "$shareware_dir/psipred/data";

# nnmake
my $VALL          = "/work/robetta/src/mini_fragpicker/databases/casp9"; # dir containing vall database (cvs repository 'nnmake_database')
my $VALL_NAME     = "vall.dat.apr24"; # filename of vall (vall.dat.<id> and vall_cst_coord.dat.<id> must exist)
my $PICKER        = "/work/tex/src/rosetta/rosetta_source/bin/fragment_picker.linuxgccrelease";

# sam (secondary structure prediction software)
my $SAM_target99		   = "$shareware_dir/sam/bin/target99";  # sam target99 executable
my $SAM_uniqueseq		   = "$shareware_dir/sam/bin/uniqueseq"; # sam uniqueseq executable
my $SAM_predict_2nd_dir	= "$shareware_dir/sam.predict2nd/";   # sam predict-2nd directory
my $SAM_predict_2nd		= "$shareware_dir/sam.predict2nd/predict-2nd";	# sam predict-2nd executable

# porter
my $PORTER = "$shareware_dir/porter/runPorter.pl";

# mini frag picker files
#my $ROSETTA_DATABASE = "$src_dir/mini_fragpicker";
my $ROSETTA_DATABASE    = "/work/tex/src/rosetta/rosetta_database";
my $SS_PRED_CONVERTER   = "$src_dir/mini_fragpicker/ss_pred_converter.py";

if ( $host =~ /nrb/ ) {
	$NR            = "/scratch/robetta/local_db/nr/nr";
	$VALL_BLAST_DB = "/work/robetta/src/mini_fragpicker/vall.blast.apr24";
	$PDB_DB        = "/work/robetta/src/mini_fragpicker/databases/pdb/pdb_seqres.txt";
	$FILTNR        = "/scratch/robetta/local_db/nr/nr";
	$VALL          = "/work/robetta/src/mini_fragpicker"; # dir containing vall database (cvs repository 'nnmake_database')
	$PICKER        = "/work/robetta/src/rosetta_server/rosetta/rosetta_source/bin/fragment_picker.linuxgccrelease";
	$ROSETTA_DATABASE    = "/work/robetta/src/rosetta_server/rosetta/rosetta_database";
}

###############################################################################
#
# MAKE_FRAGMENTS.PL 1.00 -- THE (PEN)ULTIMATE IN HOME FRAGMENT-PICKING SOFTWARE!
#
# CAUTION:  NO USER SERVICEABLE PARTS BELOW!
#
#           TO REDUCE RISK OF ELECTRIC SHOCK, DO NOT REMOVE THE COVER!
#           DO NOT ATTEMPT REPAIRS!  REFER SERVICING TO YOUR AUTHORIZED DEALER!
#           AVOID PROLONGED EXPOSURE TO HEAT OR SUNLIGHT!
#           TO REDUCE THE RISK OF FIRE OR ELECTRIC SHOCK, DO NOT EXPOSE THE
#            PRODUCT TO RAIN AND/OR MOISTURE!
#           DO NOT MOVE THE PRODUCT WHILE IN USE!
#           DO NOT LOOK AT THE PRODUCT WHILE IN USE!
#           DO NOT COMPLAIN ABOUT THE PRODUCT WHILE IN USE!
#           DO NOT DISCUSS THE PRODUCT WHILE IN USE!
#           DO NOT THINK ABOUT THE PRODUCT WHILE IN USE!
#           CLEAN ONLY WITH MILD DETERGENTS AND A SOFT CLOTH!
#           USE ONLY IN WELL-VENTILATED AREAS!
#
#           FOR EXTERNAL USE ONLY!  DO NOT TAKE INTERNALLY!
#           MAY PRODUCE STRONG MAGNETIC FIELDS!
#
#           DO NOT REMOVE THIS TAG UNDER PENALTY OF LAW.
#
#           THIS ARTICLE CONTAINS NEW MATERIAL ONLY.
#
#           THIS LABEL IS AFFIXED IN COMPLAINCE WITH THE UPHOLSTERED AND
#            STUFFED ARTICLES ACT.
#
#
# (IN OTHER WORDS:  DON'T EVEN *THINK* ABOUT CHANGING THINGS BELOW THIS POINT!)
#
###############################################################################

use Cwd qw/ cwd abs_path /;
use bytes;

my %options;
$options{DEBUG} = 0;
use constant VERSION => 2.00; # works with standard & warnings

$| = 1; # disable stdout buffering

# initialize options
my %opts = &getCommandLineOptions();
$options{fastafile}     = abs_path( $opts{f} );
$options{rundir}        = cwd();  # get the full path (needed for sam stuff)
$options{homs}          = 1;
$options{pick_frags}    = 1;
$options{psipred_file}  = "";
$options{sam_file}      = "";
$options{porter_file}   = "";
$options{psipred}       = 1;
$options{psipred_iter}  = 1;
$options{psipred_hbias} = 1;
$options{psipred_sbias} = 1;
$options{porter}        = 1;
$options{sam}           = 1;
$options{id}            = "temp";
$options{chain}         = "_";
$options{xx}            = "aa";
$options{cleanup}       = 1;
$options{torsion_bin}   = 0;

my @cleanup_files       = ();
my @fragsizes           = (3,9); #4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20 );
my @add_vall_files      = ();
my @use_vall_files      = ();

$options{n_frags}       = 200;
$options{n_candidates}  = 1000;

foreach my $key ( keys %opts ) {
	$options{$key} = $opts{$key};
}

# special option parsing
if ( $options{verbose} ) {
	$options{DEBUG} = 1;
	print_debug("Run options:\n");
	print_debug("be verbose.\n");
}

if (defined($opts{frag_sizes})) {
	@fragsizes = split(/,/, $opts{frag_sizes});
	print_debug( "fragment sizes: ".join(" ", @fragsizes)."\n" );
}

if (exists $opts{add_vall_files} ) {
	foreach my $vall (split(/,/, $opts{add_vall_files})) {
		push(@add_vall_files, $vall) if (-s $vall);
	}
}

if (exists $opts{use_vall_files}) {
	foreach my $vall (split(/,/, $opts{use_vall_files})) {
		push(@use_vall_files, $vall) if (-s $vall);
	}
}

$options{xx} = substr( $options{xx}, 0, 2 );
mkpath($options{rundir});
$options{rundir} = abs_path($options{rundir});
chop($options{rundir}) if (substr($options{rundir}, -1, 1) eq '/');
&checkExist('d',$options{rundir});

print "picking fragments with options:\n", options_to_str(\%options), "\n";
print_debug("FILENAME: $options{fastafile}\n");

if (!defined($opts{id})) {
	print_debug("no id specified. parsing filename instead.\n");

	($options{id}) = $options{fastafile} =~ /(\w+\.\w+)$/;
	print_debug("INTERMEDIATE: $options{id}\n");
	($options{id}) = $options{id} =~ /^(\w+)/;

	if (length($options{id}) != 5) {
		$options{id} = 't001_';
	}

	$options{chain} = substr($options{id}, 4, 1);
	$options{id}    = substr($options{id}, 0, 4);
	print_debug("ID: $options{id} CHAIN: $options{chain}\n");
} else {
	chomp $opts{id};

	print_debug("id specified by user: $opts{id}\n");

	if (length($opts{id}) != 5) {
		die("The id you specify must be 5 characters long.\n");
	}

	if ($opts{id} =~ /\W+/) {
		die("Only alphanumeric characters and _ area allowed in the id.\n");
	}

	$options{id} = substr($opts{id}, 0, 4);
	$options{chain} = substr($opts{id}, 4, 1);

	if (-s "$options{id}$options{chain}.fasta") {
		my @diff = `diff $options{id}$options{chain}.fasta $options{fastafile}`;
		if (scalar @diff) {
			die "ERROR! $options{id}$options{chain}.fasta already exists but does not match $options{fastafile}: $options{id}$options{chain}.fasta is autogenerated and should not exist\n";
		}
	}
	print_debug("using $options{fastafile} as query fasta\n");
	print_debug("ID: $options{id} CHAIN: $options{chain}\n");
}

if ( abs_path($options{fastafile}) ne abs_path("$options{id}$options{chain}.fasta") ) {
	copy( $options{fastafile}, "$options{id}$options{chain}.fasta" ) ;
		#or die "error copying $options{fastafile} to $options{id}$options{chain}.fasta\n";
	$options{fastafile} = "$options{id}$options{chain}.fasta";
}

# determine what ss predictions to run
foreach my $ss_pred ( qw/ porter sam psipred / ) {
	if ( $options{$ss_pred} ) {
		my $fn_key = join '_', ($ss_pred,'file');
		my $fn = $options{$fn_key};
		$options{$ss_pred} = file_overrides_option($fn,$ss_pred);
	}
}

# main
my $abs_path_fasta  = abs_path($options{fastafile});
$options{fastafile} = basename($options{fastafile});
if ( $abs_path_fasta ne abs_path( "$options{rundir}/$options{fastafile}" ) ) {
	copy( $options{fastafile}, "$options{rundir}/" )
		or die "Error copying $options{fastafile} into $options{rundir}!\n";
}
chdir($options{rundir});

# get the sequence from the fasta file
my $sequence = read_fasta($options{fastafile});
print_debug("Sequence: $sequence\n");

# run blast
unless (&nonempty_file_exists("$options{id}$options{chain}.check" )) {
	if (!&try_try_again("$PSIBLAST -t 1 -i $options{fastafile} -F F -j2 -o $options{id}$options{chain}.blast -d $NR -v10000 -b10000 -K1000 -h0.0009 -e0.0009 -C $options{id}$options{chain}.check -Q $options{id}$options{chain}.pssm",
	2, ["$options{id}$options{chain}.check"], ["$options{id}$options{chain}.check","$options{id}$options{chain}.blast","$options{id}$options{chain}.pssm","error.log"])) {
		die("checkpoint psi-blast failed!\n");
	}
}

unless (&nonempty_file_exists("$options{id}$options{chain}.checkpoint")) {
	# parse & fortran-ify the checkpoint matrix.
	my @checkpoint_matrix;
	@checkpoint_matrix = &parse_checkpoint_file("$options{id}$options{chain}.check");
	@checkpoint_matrix = &finish_checkpoint_matrix($sequence, @checkpoint_matrix);
	&write_checkpoint_file("$options{id}$options{chain}.checkpoint", $sequence, @checkpoint_matrix);
}

push(@cleanup_files,("$options{id}$options{chain}.blast","$options{id}$options{chain}.pssm","error.log"));

# Secondary Structure Prediction methods
if ($options{psipred}) {
	# run psi-blast for psipred
	unless (&nonempty_file_exists("sstmp.chk") && &nonempty_file_exists("sstmp.ascii") && &nonempty_file_exists("ss_blast")) {
		if (!&try_try_again("$PSIBLAST -t 1 -b10000 -v10000 -j3 -h0.001 -d $FILTNR -i $options{fastafile} -C sstmp.chk -Q sstmp.ascii -o ss_blast",
				2, ["sstmp.chk","sstmp.ascii"], ["sstmp.chk","sstmp.ascii","ss_blast"])) {
			die("psipred psi-blast failed!\n");
		}
		push(@cleanup_files,("ss_blast","sstmp.chk","sstmp.ascii"));
	}
}

# psipred
if ($options{psipred}) {
	print_debug("running psipred.\n");

	unless (&nonempty_file_exists("psitmp.sn")) {
		&run("echo $options{fastafile} > psitmp.sn",("psitmp.sn"));
	}
	unless (&nonempty_file_exists("psitmp.pn")) {
		&run("echo sstmp.chk > psitmp.pn", ("psitmp.pn"));
	}

	unless (&nonempty_file_exists("sstmp.mtx")) {
		if (!&try_try_again("$MAKEMAT -P psitmp", 2, ["sstmp.mtx"], ["sstmp.mtx"])) {
			die("psipred: makemat failed.");
		}
	}

	unless (&nonempty_file_exists("psipred_ss")) {
		if (!&try_try_again("$PSIPRED sstmp.mtx $PSIPRED_DATA/weights.dat $PSIPRED_DATA/weights.dat2 $PSIPRED_DATA/weights.dat3 $PSIPRED_DATA/weights.dat4 > psipred_ss",
		2, ["psipred_ss"], ["psipred_ss"])) {
			die("psipred failed.");
		}
	}

	unless (&nonempty_file_exists("psipred_horiz")) {
		if (!&try_try_again("$PSIPASS2 $PSIPRED_DATA/weights_p2.dat $options{psipred_iter} $options{psipred_hbias} $options{psipred_sbias} psipred_ss2 psipred_ss > psipred_horiz", 2, ["psipred_ss2","psipred_horiz"], ["psipred_ss2","psipred_horiz"])) {
			die("psipred/psipass2 failed.");
		}

		rename("psipred_horiz", "$options{id}$options{chain}.psipred") or die ("couldn't move psipred_horiz to $options{id}$options{chain}.psipred: $!\n");

		if (!scalar(`grep 'PSIPRED VFORMAT' psipred_ss2`)) {
			open(FILE, "psipred_ss2");
			my @ss2 = <FILE>;
			close(FILE);
			open(FILE, ">$options{id}$options{chain}.psipred_ss2");
			print FILE "# PSIPRED VFORMAT (PSIPRED V2.6 by David Jones)\n\n";
			print FILE @ss2;
			close(FILE);
		} else {
			rename("psipred_ss2", "$options{id}$options{chain}.psipred_ss2") or die ("couldn't move psipred_ss2 to $options{id}$options{chain}.psipred_ss2: $!\n");
		}
	}

	if (&nonempty_file_exists("$options{id}$options{chain}.psipred_ss2")) {
		print_debug("psipred file ok.\n");
	} else {
		print "psipred run failed!\n";
	}

	push(@cleanup_files,(glob("psitmp*"),"psipred_ss","sstmp.mtx"));
}

if ($options{porter}) {
	print_debug("running porter.\n");
	if (!&try_try_again("$PORTER $options{fastafile}", 2, ["$options{id}$options{chain}.porter_ss2"], ["$options{id}$options{chain}.porter_ss2"])) {
		die("porter failed!\n");
	}
}

# sam -- target99 alignment and predict2nd with 6 state neural net - condensed output to 3 state
if ($options{sam}) {
	print_debug("running sam.\n");

	my $target99_out = $options{id}.$options{chain}.".target99";
	my $target99_a2m_file = $target99_out.".a2m";

	if (!&try_try_again("$SAM_target99 -seed $options{fastafile} -out ".$target99_out, 2, [$target99_a2m_file], [])) {
		die "sam target99 failed!\n";
	}

	## run uniqueseq
	my $uniqueseq_a2m_id	= $options{id}.$options{chain}.".uniqueseq";
	my $uniqueseq_a2m_file	= $uniqueseq_a2m_id.".a2m";
	if (!&try_try_again("$SAM_uniqueseq $uniqueseq_a2m_id -percent_id 0.9 -alignfile ".$target99_a2m_file, 2, [$uniqueseq_a2m_file], [$uniqueseq_a2m_file])) {
		die "sam uniqueseq failed!\n";
	}

	## run predict-2nd
	chop($SAM_predict_2nd_dir) if (substr($SAM_predict_2nd_dir, -1, 1) eq '/');

	# create samscript
	my $sam_6state = "$options{rundir}/$options{id}$options{chain}.sam_6state";
	my $sam_ebghtl = "$options{rundir}/$options{id}$options{chain}.sam_ebghtl";
	my $sam_log    = "$options{rundir}/$options{id}$options{chain}.sam_log";
	my $samscript_txt_buf =
	qq{ReadAlphabet $SAM_predict_2nd_dir/std.alphabet
		ReadAlphabet $SAM_predict_2nd_dir/DSSP.alphabet
		ReadNeuralNet $SAM_predict_2nd_dir/overrep-3617-IDaa13-7-10-11-10-11-7-7-ebghtl-seeded3-stride-trained.net
		ReadA2M $options{rundir}/$uniqueseq_a2m_file
		PrintRDB $sam_6state
		PrintPredictionFasta $sam_ebghtl
	};
	my $samscript_txt = "$options{rundir}/$options{id}$options{chain}.samscript.txt";
	open  (SAMSCRIPT, '>'.$samscript_txt);
	print  SAMSCRIPT $samscript_txt_buf;
	close (SAMSCRIPT);

	# get into $SAM_predict_2nd_dir so sam can read file recode3.20comp
	chdir $SAM_predict_2nd_dir;
	if (!&try_try_again("$SAM_predict_2nd -noalph < $samscript_txt >& $sam_log", 2, [$sam_6state], [$sam_6state])) {
		die "sam predict-2nd failed!\n";
	}
	chdir $options{rundir};

	# condense to 3 state prediction
	# formerly a separate perl script: condense_6state.pl
	my $rows;
	open IN, "<$sam_6state" or die "Cannot open file $sam_6state: $!\n";
	@{$rows} = <IN>;
	close (IN);
	$rows = &condense_rdb6_rdb($rows);
	open OUT, ">$options{id}$options{chain}.rdb" or die "Cannot open file $options{id}$options{chain}.rdb: $!\n";
	print OUT @{$rows};
	close (OUT);

	# convert rdb to rdb_ss2
	system("$SS_PRED_CONVERTER -s $options{id}$options{chain}.rdb > $options{id}$options{chain}.rdb_ss2");
	if (!-s "$options{id}$options{chain}.rdb_ss2") {
		die("SAM failed!\n");
	}

	print_debug("sam file ok.\n");

	push @cleanup_files, ($samscript_txt, $sam_log, $sam_6state,$sam_ebghtl,$target99_a2m_file,$uniqueseq_a2m_file,"$target99_out.cst");
}

# convert SAM rdb format to rdb_ss2 format
if ( &nonempty_file_exists("$options{rundir}/$options{id}$options{chain}.rdb")) {
	# convert rdb to rdb_ss2
	my $cmd = "$SS_PRED_CONVERTER -s $options{rundir}/$options{id}$options{chain}.rdb > $options{rundir}/$options{id}$options{chain}.rdb_ss2";
	produce_output_with_cmd( $cmd, "$options{rundir}/$options{id}$options{chain}.rdb_ss2" );
}


# Vall and homolog searches
if (!$options{homs}) {
	unless (&nonempty_file_exists("$options{id}$options{chain}.outn")) {
		if (!&try_try_again("$PSIBLAST -t 1 -i $options{fastafile} -j 1 -R $options{id}$options{chain}.check -o $options{id}$options{chain}.outn -e 0.05 -d $VALL_BLAST_DB", 2, ["$options{id}$options{chain}.outn"], ["$options{id}$options{chain}.outn"])) {
			die("homolog vall blast failed!\n");
		}
	}

	unless (&nonempty_file_exists("$options{id}$options{chain}.outn.pdb")) {
		if (!&try_try_again("$PSIBLAST -t 1 -i $options{fastafile} -j 1 -R $options{id}$options{chain}.check -o $options{id}$options{chain}.outn.pdb -e 0.05 -d $PDB_DB", 2, ["$options{id}$options{chain}.outn.pdb"], ["$options{id}$options{chain}.outn.pdb"])) {
			die("homolog pdb blast failed!\n");
		}
	}

	&exclude_blast($options{id},$options{chain});
	&exclude_blast($options{id},$options{chain});
	&exclude_pdbblast($options{id},$options{chain});
	&exclude_outn($options{id},$options{chain});
}

if (!$options{pick_frags}) {
	cleanup(@cleanup_files);
	exit 0;
}

# picker
my @valls = ( "$VALL/$VALL_NAME" );
push(@valls, @add_vall_files) if (scalar @add_vall_files);

if ( scalar @use_vall_files ) {
	@valls = @use_vall_files;
}
my $valls_str = join ' ', @valls;

my $score_def = <<SCORE;
# score name         priority  wght   min_allowed  extras
ProfileScoreL1          300     1.0     -
RamaScore               100     1.0     -       psipred
SCORE
foreach my $ss_pred ( qw/ psipred sam porter / ) {
	if ( $options{$ss_pred} ) {
		$score_def .= "SecondarySimilarity     200     1.0     -       $ss_pred\n";
	}
}
if ( $options{torsion_bin} && -f $options{torsion_bin} ) {
	$score_def .= "TorsionBinSimilarity    100     1.0     -\n";
}
open FILE, ">scores.cfg";
print FILE $score_def;
close FILE or die $!;

foreach my $size (@fragsizes) {
	open(PATH_DEFS, ">picker_cmd_size$size.txt");
	my $cmdtxt = <<CMDTXT;
-in:file:fasta		      $options{fastafile}
-in:path:database       $ROSETTA_DATABASE
-in:file:vall           $valls_str
-frags:n_candidates	   $options{n_candidates}
-frags:n_frags		      $options{n_frags}
-frags:frag_sizes	      $size
-out:file:frag_prefix   $options{xx}$options{id}$options{chain}
-frags:scoring:config   scores.cfg
-out:level 200
-in:file:checkpoint     $options{id}$options{chain}.checkpoint
-frags:write_ca_coordinates
-frags:describe_fragments frags.$size.score
CMDTXT

	# add fragment secondary structure predictions
	my @frag_ss_tokens;
	if ( -f "$options{id}$options{chain}.psipred_ss2" ) { push @frag_ss_tokens, ("$options{id}$options{chain}.psipred_ss2", "psipred"); }
	if ( -f "$options{id}$options{chain}.rdb_ss2" ) { push @frag_ss_tokens, ("$options{id}$options{chain}.rdb_ss2", "sam"); }
	if ( -f "$options{id}$options{chain}.porter_ss2" ) { push @frag_ss_tokens, ("$options{id}$options{chain}.porter_ss2", "porter"); }
	$cmdtxt .= join ' ', ( '-frags:ss_pred', @frag_ss_tokens );
	$cmdtxt .= "\n";
	if ( $options{torsion_bin} && -f $options{torsion_bin} ) {
		$cmdtxt .= "-in:file:torsion_bin_probs $options{torsion_bin}\n";
	}

	# auto-generate quota votes
	my %votes;
	foreach my $ss_pred ( qw/ psipred porter sam / ) {
		if ( $options{$ss_pred} ) {
			$votes{$ss_pred} = get_ss_quota_vote($ss_pred);
		}
	}

	if ( scalar(keys %votes) > 0 ) {
		my $quota_fn = "Quota.def";
		open  QUOTA, ">$quota_fn" or die $!;
		print QUOTA "#pool_id        pool_name       fraction\n";
		my $count = 1;

		use List::Util qw/ sum /;
		my $sum = sum(values %votes);
		foreach my $ss_pred ( keys %votes ) {
			my $pct = sprintf( "%4.2f", $votes{$ss_pred} / $sum );
			print QUOTA "$count          $ss_pred        $pct\n";
			$count++;
		}
		$cmdtxt .= "-frags:picking:quota_config_file $quota_fn\n";
	}

	if (!$options{homs}) {
		$cmdtxt .= "-frags:denied_pdb $options{id}$options{chain}.homolog\n";
	}

	print PATH_DEFS $cmdtxt;
	close(PATH_DEFS);
}

foreach my $size (@fragsizes) {
	my $cmd = "$PICKER \@picker_cmd_size$size.txt >& $size.log";
	produce_output_with_cmd($cmd,"$size.log");
}

# done
exit 0;

# subroutines
sub check_fragformat {
	my ($fasta, $frag, $verbose) = @_;
	chomp $fasta;
	chomp $frag;
	my $seq;
	print "Checking frag file format: $frag\n" if ($verbose);
	open(F, $fasta) or die "ERROR! cannot open $fasta: $!\n";
	while (<F>) {
		next if (/^>/);
		$seq .= $_;
	}
	close(F);
	$seq =~ s/\s+//gs;
	my (@n, $pos, $nbrs, $nbrscnt, $prevnbrs, $fragsize);
	my $poscnt = 0;
	open(F, $frag) or die "ERROR! cannot open $frag: $!\n";
	while (<F>) {
		if (/^\s*position:\s+(\d+)\s+neighbors:\s+(\d+)\s*$/) {
			$prevnbrs = $nbrs;
			$pos = $1; $nbrs = $2;
			$poscnt++;
			if ($prevnbrs != $nbrscnt) {
				die "ERROR! neighbor truncated\n";
			}
			$nbrscnt = 0;
		} elsif (/^\s+\w\w\w\w\s+[\w\-]\s+\d+/) {
			push(@n, $_);
		} elsif (/^\s*$/) {
			if (scalar@n) {
				if (!$nbrscnt) {
					$fragsize = scalar@n;
				} else {
					if (scalar@n != $fragsize) {
						die "ERROR! neighbor count off\n";
					}
				}
				$nbrscnt++;
			}
			@n = ();
		}
	}
	close(F);

	if ($nbrs != $nbrscnt) {
		die "ERROR! neighbor truncated\n";
	}

	if (length($seq) != $pos+$fragsize-1) {
	  my $len = length($seq);
	  my $poslen = $pos+$fragsize-1;
	  die "ERROR! fasta seq length $len does not match positions $poslen\n";
	}
	print "Format okay!\n" if ($verbose);
}

# getCommandLineOptions()
# rets: \%opts  pointer to hash of kv pairs of command line options
sub getCommandLineOptions {
	use Getopt::Long;

	my $usage = qq{usage: $0  [-rundir <full path to run directory (default = ./)>
		\t-verbose  specify for chatty output
		\t-id  <5 character pdb code/chain id, e.g. 1tum_>
		\t-nopsipred  don\'t run psipred.
		\t-psipred_iter  \# of psipred iterations
		\t-psipred_hbias  psipred helix bias
		\t-psipred_sbias  psipred strand bias
		\t-nosam  don\'t run sam.
		\t-noporter  don\'t run porter.
		\t-nohoms  specify to omit homologs from search
		\t-psipredfile  <path to file containing psipred ss prediction>
		\t-samfile  <path to file containing sam ss prediction>
		\t-phdfile  <path to file containing phd ss prediction>
		\t-porterfile  <path to file containing porter ss prediction>
		\t-minss  <minimum \# ss predictions needed (default=1)>
		\t-xx  <silly little 2-letter code, if you care>
		\t-nocleanup  specify to keep all the temporary files
		\t-add_vall_files <vall1,vall2,...> add extra Vall files
		\t-use_vall_files <vall1,vall2,...> use only the following Vall files
		\t-frag_sizes <size1,size2,...n>
		\t-nofrags specify to not make fragments and just run SS predictions
		\t-n_frags <number of fragments>
		\t-n_candidates <number of candidates>
		\t<fasta file>
	};
	$usage = "$usage\n\n" . join ' ', ( 'Version:', VERSION, "\n" );

	# Get args
	my %opts;
	&GetOptions(
		\%opts,
		"psipred!",
		"psipred_iter=f",
		"psipred_hbias=f",
		"psipred_sbias:f",
		"sam!",
		"homs!",
		"frags!",
		"porter!",
		"psipredfile=s",
		"samfile=s",
		"phdfile=s",
		"porterfile=s",
		"xx=s",
		"verbose!",
		"rundir=s",
		"id=s",
		"minss=i",
		"cleanup!",
		"frag_sizes=s",
		"n_frags=i",
		"n_candidates=i",
		"add_vall_files=s",
		"use_vall_files=s",
		"torsion_bin=s",
	);

	if (scalar(@ARGV) != 1) {
		die "$usage\n";
	}

	$opts{f} = $ARGV[0];

	if ( $opts{f} =~ /[^\w\.\/]/ ) {
		die("Only alphanumeric characters, . and _ are allowed in the filename.\n");
	}

	&checkExist("f",$opts{f});
	if (defined $opts{frag_sizes} && $opts{frag_sizes} !~ /^[\d\,]+$/) {
		die "Fragment sizes are invalid\n";
	}

	if ( wantarray ) { return %opts; }
	return \%opts;
}

sub checkExist {
	my ($type, $path) = @_;
	if ($type eq 'd') {
		if (! -d $path) {
			print STDERR "$0: dirnotfound: $path\n";
			exit -3;
		}
	} elsif ($type eq 'f') {
		if (! -f $path) {
			print STDERR "$0: filenotfound: $path\n";
			exit -3;
		} elsif (!-s $path) {
			print STDERR "$0: emptyfile: $path\n";
			exit -3;
		}
	}
}

sub nonempty_file_exists {
	my $file = shift;
	return ( -f $file && ! -z $file );
}

sub run {
	my ($cmd, @files) = @_;
	my $pid;

	print_debug("cmd is: $cmd\n");

	FORK: {
		if ($pid = fork) {
			# parent
			local $SIG{TERM} = sub {
				kill 9, $pid;
				`rm -f @files`;
				exit;
			};

			local $SIG{INT} = sub {
				kill 9, $pid;
				`rm -f @files`;
				exit;
			};

			wait;

			return $?;
		} elsif (defined $pid) {
			# child process
			exec($cmd);
		} elsif ($! =~ /No more process/) {
			# recoverable error
			sleep 5;
			redo FORK;
		} else {
			# unrecoverable error
			die ("couldn't fork: $!\n");
		}
	}
}

sub try_try_again {
	my ($cmd, $max_tries, $success_files, $cleanup_files) = @_;
	my $try_count = 0;
	my $missing_files = 1;
	my $f;

	# if at first you don't succeed in running $cmd, try, try again.
	while (($try_count < $max_tries) && ($missing_files > 0)) {
		sleep 10;
		&run($cmd,@$cleanup_files);
		++$try_count;

		$missing_files = 0;

		foreach $f (@$success_files) {
			if (!&nonempty_file_exists($f)) {
				++$missing_files;
			}
		}
	}

	# but if you've tried $max_tries times, give up.
	# there's no use being a damn fool about things.
	if ($missing_files > 0) {
		return 0;
	}

	return 1;
}

sub exclude_outn {
	my ($pdb, $chain) = @_;
	my @hits;
	my $hit;
	my $hit_pdb;
	my $hit_chain;
	my %uniq_hits;

	open(OUTN, "$pdb$chain.outn");
	open(EXCL, ">$pdb$chain.homolog_vall");
	open(EXCL2, ">>$pdb$chain.homolog");

	@hits = grep(/^>/,<OUTN>);

	foreach $hit (@hits) {
		$uniq_hits{$hit} = 1;
	}

	foreach $hit (sort keys %uniq_hits) {
		($hit_pdb) = $hit =~ /^>\s*(\w+)/;
		$hit_chain = substr($hit_pdb, 4, 1);
		$hit_pdb = substr($hit_pdb, 0, 4);

		$hit_pdb =~ tr/[A-Z]/[a-z]/;
		$hit_chain = '_' if ($hit_chain eq ' ');
		$hit_chain = '_' if ($hit_chain eq '0');

		print EXCL "$pdb$chain $hit_pdb$hit_chain\n";
		print EXCL2 "$pdb$chain $hit_pdb$hit_chain\n";
	}

	close(EXCL);
	close(EXCL2);
}

sub exclude_pdbblast {
	my ($pdb, $chain) = @_;
	my @hits;
	my $hit;
	my $hit_pdb;
	my $hit_chain;
	my %uniq_hits;

	open(OUTN, "$pdb$chain.outn.pdb");
	open(EXCL, ">$pdb$chain.homolog_pdb");
	open(EXCL2, ">>$pdb$chain.homolog");

	@hits = grep(/^>/,<OUTN>);

	foreach $hit (@hits) {
		$uniq_hits{$hit} = 1;
	}


	foreach $hit (sort keys %uniq_hits) {
		($hit_pdb) = $hit =~ /^>\s*(\w+)/;
		$hit_chain = substr($hit_pdb, 4, 1);
		$hit_pdb = substr($hit_pdb, 0, 4);

		$hit_pdb =~ tr/[A-Z]/[a-z]/;
		$hit_chain = '_' if ($hit_chain eq ' ');
		$hit_chain = '_' if ($hit_chain eq '0');

		print EXCL "$pdb$chain $hit_pdb$hit_chain\n";
		print EXCL2 "$pdb$chain $hit_pdb$hit_chain\n";
	}

	close(EXCL);
	close(EXCL2);
}

sub exclude_blast {
	my ($pdb, $chain) = @_;
	my @hits;
	my $hit;
	my $hit_pdb;
	my $hit_chain;
	my %uniq_hits;

	open(BLAST, "$pdb$chain.blast");
	open(EXCL, ">$pdb$chain.homolog_nr");
	open(EXCL2, ">>$pdb$chain.homolog");

	@hits = grep(/pdb\|/, <BLAST>);

	foreach $hit (@hits) {
		$uniq_hits{$hit} = 1;
	}

	foreach $hit (sort keys %uniq_hits) {
		while ($hit =~ s/pdb\|(\w{4})\|(.?)//) {
			$hit_pdb   = $1;
			$hit_chain = $2;

			$hit_pdb   =~ tr/[A-Z]/[a-z]/;
			$hit_chain = '_' if ($hit_chain =~ /^\s*$/);

			print EXCL "$pdb$chain $hit_pdb$hit_chain\n";
			print EXCL2 "$pdb$chain $hit_pdb$hit_chain\n";
		}
	}

	close(EXCL);
	close(EXCL2);
}

## parse_checkpoint_file -- parses a PSI-BLAST binary checkpoint file.
#
# args:  filename of checkpoint file.
# rets:  N x 20 array containing checkpoint weight values, where N
#        is the size of the protein that BLAST thought it saw...

sub parse_checkpoint_file {
	my $filename = shift;
	my $buf;
	my $seqlen;
	my $seqstr;
	my $i;
	my $j;
	my @aa_order = split(//,'ACDEFGHIKLMNPQRSTVWY');
	my @altschul_mapping = (0,4,3,6,13,7,8,9,11,10,12,2,14,5,1,15,16,19,17,18);
	my @w;
	my @output;

	open(INPUT, $filename) or die ("Couldn't open $filename for reading.\n");

	read(INPUT, $buf, 4) or die ("Couldn't read $filename!\n");
	$seqlen = unpack("i", $buf);

	print_debug("Sequence length: $seqlen\n");

	read(INPUT, $buf, $seqlen) or die ("Premature end: $filename.\n");
	$seqstr = unpack("a$seqlen", $buf);

	for ($i = 0; $i < $seqlen; ++$i) {
		read(INPUT, $buf, 160) or die ("Premature end: $filename, line: $i\n");
		@w = unpack("d20", $buf);

		for ($j = 0; $j < 20; ++$j) {
			$output[$i][$j] = $w[$altschul_mapping[$j]];
		}
	}

	return @output;
}

## finish_checkpoint_matrix -- "finishes" the parsed PSI-BLAST checkpoint matrix,
##                             by adding pseudo-counts to any empty columns.
#
# args:  1) sequence string  2) array returned by parse_checkpoint_file
# rets:  "finished" array.  suitable for printing, framing, etc.

sub finish_checkpoint_matrix {
	my ($s, @matrix) = @_;
	my @sequence = split(//,$s);
	my $i;
	my $j;
	my $line;
	my $sum;
	my @words;
	my @b62;
	my @blos_aa = (0,14,11,2,1,13,3,5,6,7,9,8,10,4,12,15,16,18,19,17);

	my %aaNum = (
		A => 0, C => 1, D => 2, E => 3, F => 4, G => 5, H => 6, I => 7, K => 8,
		L => 9, M => 10, N => 11, P => 12, Q => 13, R => 14, S => 15, T => 16,
		V => 17, W => 18, Y => 19, X => 0
	);

	(length($s) == scalar(@matrix))
		or die ("Length mismatch between sequence and checkpoint file!\n");

	open(B62,"$BLOSUM_PATH/blosum62.qij") or die "couldnt find blosum62 table\n";
	$i = 0;

  # read/build the blosum matrix
  while (<B62>) {
    next if ($_ !~ /^\d/);
    chomp;
    @words = split(/\s/);

    for ($j = 0; $j <= $#words; ++$j) {
      $b62[$blos_aa[$i]][$blos_aa[$j]] = $words[$j];
      $b62[$blos_aa[$j]][$blos_aa[$i]] = $words[$j];
    }

    ++$i;
  }

  # normalize the blosum matrix so that each row sums to 1.0
  for ($i = 0; $i < 20; ++$i) {
    $sum = 0.0;

    for ($j = 0; $j < 20; ++$j) {
      $sum += $b62[$i][$j];
    }

    for ($j = 0; $j < 20; ++$j) {
      $b62[$i][$j] = ($b62[$i][$j] / $sum);
    }
  }

  # substitute appropriate blosum row for 0 rows
  for ($i = 0; $i <= $#matrix; ++$i) {
    $sum = 0;

    for ($j = 0; $j < 20; ++$j) {
      $sum += $matrix[$i][$j];
    }

    if ($sum == 0) {
      for ($j = 0; $j < 20; ++$j) {
			$matrix[$i][$j] = $b62[$aaNum{$sequence[$i]}][$j];
      }
    }
  }

  return @matrix;
}

sub write_checkpoint_file {
  my ($filename, $sequence, @matrix) = @_;
  my $row;
  my $col;
  my @seq = split(//,$sequence);

  open(OUTPUT, ">$filename");

  die ("Length mismatch between sequence and checkpoint matrix!\n") unless (length($sequence) == scalar(@matrix));

  print OUTPUT scalar(@matrix),"\n";

  for ($row = 0; $row <= $#matrix; ++$row) {
    print OUTPUT "$seq[$row] ";
    for ($col = 0; $col < 20; ++$col) {
      printf OUTPUT "%6.4f ", $matrix[$row][$col];
    }
    print OUTPUT "\n";
  }

  print OUTPUT "END";

  close(OUTPUT);
}

# Verifies a checkpoint file to make sure it's kosher.
# arg: filename of checkpoint file.
# returns: 1 if good, 0 if bad.
sub verify_existing_checkpoint {
  my $filename = shift;
  my @file;

  open(CPT, $filename) || return 0;
  print_debug("opened checkpoint file.\n");

  @file = <CPT>;

  ($file[0] =~ /^(\d+)$/) || return 0;
  print_debug("starting line ok.\n");

  ((scalar(@file) - 2) == $1) || return 0;
  print_debug("length ok.\n");

  ($file[$#file] =~ /^END/) || return 0;
  print_debug("end ok.\n");

  close(CPT);
  return 1;
}

## convert 6 state rdb file to 3 state
sub condense_rdb6_rdb {
	my($rows)=@_;
	my($outrows,@parts,$line);
	for (@{$rows}) {
		if ( /^#/) {
			push (@{$outrows}, $_);
		} elsif (/^Pos/) {
			push (@{$outrows}, "Pos\tAA\tE\tH\tL\n");
		} elsif (/^10N/) {
			push (@{$outrows}, "10N\t1S\t5N\t5N\t5N\n");
		} elsif (/^[0-9]/) {
			@parts = split;
			die "Wrong number of columns in results row: $_\n" if $#parts != 7;
			$line = sprintf "%8s\t%1s\t%8s\t%8s\t%8s\n",$parts[0]-1,$parts[1],$parts[2]+$parts[3],$parts[4]+$parts[5],$parts[6]+$parts[7];
			push (@{$outrows}, $line);
		} else {
			die "Unrecognized row: $_\n";
		}
	}
	return $outrows;
}

sub print_debug {
	if ( !$options{DEBUG} ) {
		foreach my $line (@_) {
			print $line;
		}
	}
}

sub cleanup {
	if ($options{cleanup}) {
		foreach my $file (@cleanup_files) {
			print_debug("removing file $file");
			unlink($file);
		}
	}
}

sub options_to_str {
	my $options = shift;

	my $str = '';

	use List::Util qw/ max /;
	my $max_width  = max map { length($_) } keys %$options;
	my $format_str = "%" . $max_width . "s";
	foreach my $key ( sort keys %$options ) {
		my $val_str = $options->{$key};
		if ( ref($options->{$key}) eq 'ARRAY' ) {
			$val_str = join ' ', @{ $options->{$key} };
		} elsif ( ref($options->{$key}) eq 'HASH' ) {
			my @keys = keys %{ $options->{$key} };
			$val_str = join ', ',
				map { join ': ', ( $_, $options->{$key}{$_} ) } @keys;
		}
		$str .= join ': ', ( sprintf( $format_str, $key ), $val_str );
		$str .= "\n";
	}
	$str .= '-' x 80 . "\n";
	return $str;
}

sub produce_output_with_cmd {
	my $cmd = shift;
	my $output_fn = shift;

	print_debug( "Command: $cmd" );
	if ( -f $output_fn ) {
		print_debug( "Skipping command, $output_fn exists!" );
		return;
	}

	my $output = `$cmd`;
	print_debug( "Finished running command: $cmd" );
	if ( defined $output ) {
		print_debug( "Output: $output" );
	}

	if ( ! -f $output_fn ) {
		die "Error: expected creation of $output_fn after running '$cmd'!\n";
	}
}

sub read_fasta {
	my $fn = shift;

	open(SEQFILE, $fn) or die "Error opening fasta file $fn!\n";;
	my $has_comment = 0;
	my $eof;
	my $seq = '';
	while ( my $line = <SEQFILE>) {
		$eof  = $line;
		$line =~ s/\s//g;
		if ( $line =~ /^>/) {
			$has_comment = 1;
		} else {
			chomp $line;
			$seq .= $line;
		}
	}

	my $has_eof = ($eof =~ /\n$/);
	($has_comment && $has_eof)
		or die "fasta file (given $fn) must have a comment and end with a new line!\n";
	close SEQFILE or die $!;

	return $seq;
}

sub get_ss_quota_vote {
	my $ss_pred_name = shift;

	if ( $ss_pred_name eq 'psipred' ) {
		return 3;
	} elsif ( $ss_pred_name eq 'sam' ) {
		return 1;
	} elsif ( $ss_pred_name eq 'porter' ) {
		return 1;
	} else {
		die "Error: don't recognize ss_pred_name $ss_pred_name!\n";
	}
}

sub file_overrides_option {
	my $fn  = shift;
	my $tag = shift;

	if ( nonempty_file_exists($fn) ) {
		my $fn_base = basename($fn);
		if ( abs_path("$options{rundir}/$fn_base") ne abs_path($fn) ) {
			copy( $fn, "$options{rundir}/$fn_base" )
				or die "Error copying $fn -> $options{rundir}/$fn_base";
			push(@cleanup_files, $fn_base);
		}

		print "Assuming $options{rundir}/$fn_base is a $tag file.\n";
		return 0;
	}
	print "File for $tag not found! Generating from scratch instead.\n";
	if (length($fn)) {
		print "(given fn $fn)\n";
	}
	return 1;
}
