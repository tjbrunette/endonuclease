#!/usr/bin/perl

use strict;
use warnings;
use Cwd;

use Getopt::Long;
use File::Basename;
use Sys::Hostname;
use Fcntl ':flock';

use FindBin;
use lib "$FindBin::Bin/../perl_lib";
use Rosetta::Job qw/ run_jobs_in_parallel /;
use Rosetta::Util qw/ options_to_str /;
use Rosetta::Sequence qw/ read_protein_fasta_fn /;

my %options;
$options{script_base}     = dirname($0);
$options{max_templates}   = 100;
$options{sort}            = 1;
$options{renumber_offset} = 0;
$options{aln_dir}         = getcwd;

&GetOptions(
	\%options,
	"outfile=s",
	"max_templates=i",
	"renumber_offset=i",
	"sort!",
	"aln_dir=s",
);

$options{raptor_dir} = '/work/robetta/src/rosetta_server/bin/RaptorX';

# get an exclusive lock so only one process can run at a time on this host
my $host = hostname;
my $script = $0;
$script =~ s/^.*\/([^\/]+)\s*$/$1/gs;
my $lockfile = "$options{raptor_dir}/$script.$host.lockfile";
$lockfile =~ s/\s+/\_/gs;
open(LOCKF, ">>$lockfile") or die "Could not open '$lockfile' - $!";
flock(LOCKF, LOCK_EX) or die "Could not lock '$lockfile' - $!";

# now we are locked!

# get a unique run directory on scratch
my $pid = $$;
my $epoch = time;
my $runid = "RaptorX-$host-$pid-$epoch";
$runid =~ s/\s+/\_/gs;
$options{raptor_scratch_run_dir} = "/scratch/tmp/$runid";

# clean old jobs from the scratch drive just in case they exist from a previous failed run
# i.e. lets not keep billions of files and crush the filesystem
system("rm -rf /scratch/tmp/RaptorX-$host-*");

# copy a new instance of the Raptor run directory onto the scratch drive
# this should eventually get removed when this script is done
mkdir($options{raptor_scratch_run_dir}) or die "Could not mkdir '$options{raptor_scratch_run_dir}' - $!";
system("rsync -avz $options{raptor_dir}/RaptorX_version_to_run_on_scratch/* $options{raptor_scratch_run_dir}/");

# create scripts that are called by the raptor binary
# we need to do this so that the correct scratch path is used
my $genHMM=<<GENHMM;
#!/bin/bash
#$ -S /bin/bash

### Change to the current working directory:
#$ -cwd

### Export some environment varaibles:
#$ -V

#RaptorX_HOME=/home/wangsheng/WS_MKSEQ_Full
RaptorX_HOME="$options{raptor_scratch_run_dir}"
cd \$RaptorX_HOME/util/HHpred
f=`echo \$(basename \$1 .seq)`
./buildali2.pl \$RaptorX_HOME/tmp/\$f.seq
./hhmake -i \$RaptorX_HOME/tmp/\$f.a3m
GENHMM

open(F, ">$options{raptor_scratch_run_dir}/util/genHMM.sh") or die "Cannot open $options{raptor_scratch_run_dir}/util/genHMM.sh - $!";
print F $genHMM;
close(F);
system("chmod 755 $options{raptor_scratch_run_dir}/util/genHMM.sh");

my $genMTX=<<GENMTX;
#!/bin/bash
#$ -S /bin/bash

### Change to the current working directory:
#$ -cwd

### Export some environment varaibles:
#$ -V

#RaptorX_HOME=/home/wangsheng/WS_MKSEQ_Full
RaptorX_HOME="$options{raptor_scratch_run_dir}"
BLAST_HOME=\$RaptorX_HOME/util/BLAST
cd \$RaptorX_HOME/tmp
echo \$1.seq > \$1.sn
echo \$1.chk > \$1.pn
\$BLAST_HOME/bin/makemat -P \$1
rm \$1.sn
rm \$1.pn
GENMTX

open(F, ">$options{raptor_scratch_run_dir}/util/genMTX.sh") or die "Cannot open $options{raptor_scratch_run_dir}/util/genMTX.sh - $!";
print F $genMTX;
close(F);
system("chmod 755 $options{raptor_scratch_run_dir}/util/genMTX.sh");


## okay, now lets run stuff..............

my $fasta = $ARGV[0];

my $fasta_id = basename($fasta,".fasta");


if ( !$options{outfile} ) {
	$options{outfile} = "$fasta_id.raptor.filt";
}

my $aln_dir = $options{aln_dir};
my $buildSeqFeature_exe = "./buildSeqFeature";
my $raptor_exe = "$options{raptor_scratch_run_dir}/RXSearch_mpi.exe";
my $target_dir = "$options{raptor_scratch_run_dir}/TARGET";
my $fasta_dir = "$options{raptor_scratch_run_dir}/FASTA";
my $tmp_dir = "$options{raptor_scratch_run_dir}/tmp";
my $seq_dir = "$options{raptor_scratch_run_dir}/SEQ";

# this hopefully should be okay since only one instance is allowed
my $range = 99999;

my $id = int(rand($range));
my $seq_name = $id . ".seq";
while(-e "$seq_dir/$seq_name"){
	$id = int(rand($range));
	$seq_name = "$id".".seq";
}
#Raptor uses a common name for all of the files.
#Files with this name will be erased at the end of script
system("cp $fasta $seq_dir/$seq_name");

print STDERR "running with the following options:\n";
print STDERR options_to_str( \%options ), "\n";

if ( -f $options{outfile} ) {
	die "Error: not overwriting $fasta.filt!\n";
}

print "running raptor ... ";


#=======running buildSeqFeature=========================================
chdir $options{raptor_scratch_run_dir};
my $job = Rosetta::Job->new(
	executable	 => "$buildSeqFeature_exe",
	results_file => "$target_dir/$id".".tgt",
	args	     => [
		"$id",
	],
	dir	     => '.',
	lockfile     => "$seq_name.raptor.lock",
);

$job->run_with_message( "building seq features for raptor with $seq_name" );
#=======running raptor=========================================
$job = Rosetta::Job->new(
	executable   => "mpirun -np 14 $raptor_exe",
	results_file => "$aln_dir/$fasta_id.raptor_aln",
	args	     => [
		"-i $id -o $aln_dir/$fasta_id.raptor_aln",
	],
	dir	     => '.',
	lockfile     => "$seq_name.raptor.lock",
);
$job->run_with_message( "searching raptor database with $seq_name" );
#=======convert alignment=========================================
chdir $aln_dir;
my $sort_option = "-sort";
if($options{sort} == 0){
	$sort_option = "-nosort"
}
my $convert_job = Rosetta::Job->new(
	executable => "$options{script_base}/convert_aln.pl",
	args	   => [
		"-format_in raptor",
		"-format_out grishin",
		"-max_templates ",$options{max_templates},
		$sort_option,
		"-renumber_offset ",$options{renumber_offset},
		"-unique ",
		"$fasta_id.raptor_aln",
		"> $options{outfile}",
	],
	lockfile     => "convert.$options{outfile}.lock",
	results_file => $options{outfile},
	dir	     => "$aln_dir",
);
$convert_job->run_with_message(
	"combining alignments into $options{outfile}"
);



# clean up
# clean jobs from the scratch drive
system("rm -rf /scratch/tmp/RaptorX-$host-*");

# unlock!
close(LOCKF) or die "Could not write '$lockfile' - $!";

# DONE!
print "done!\n";



