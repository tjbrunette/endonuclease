#!/usr/bin/perl

use strict;
use warnings;

use lib '/work/tex/src/cm_scripts/perl_lib';

use Cwd qw/ getcwd abs_path /;

use blast;
use hhsearch;
use alignment;

use Rosetta::Job;
use Rosetta::Util;

use List::Util qw/ shuffle /;
use File::Path;
use File::Copy;
use Getopt::Long;
use File::Basename;
use Text::Template;
use Data::Dumper::Simple;

$0 = basename $0;
my $usage = <<USAGE;
usage:  $0 [options] aln_fn fasta_fn
options:
	--native <native_fn>
	--n_rounds <int>
	--n_procs <int>
	--make_profiles
	--dir <working_dir>
USAGE

my %options;
$options{n_procs}       = 4;
$options{n_rounds}      = 5;
$options{native}        = 0;
$options{make_profiles} = 1;
&GetOptions(
	\%options,
	"dir=s",
	"n_procs=i",
	"native=s",
	"n_rounds=i",
	"make_profiles!",
);

my $aln_file = $ARGV[0];
my $fasta    = $ARGV[1];

if ( ! file_exists($fasta) ) {
	die "Error: fasta must exist!\n$usage\n";
}

if ( ! file_exists($aln_file) ) {
	die "Error: aln_file must exist!\n$usage\n";
}

my $id = basename($fasta,'.fasta');
if ( !defined $options{dir} ) {
	$options{dir} = $id;
}

my $working_dir = $options{dir};
my $result_file = "$id.aln.dat";

mkpath $options{dir};
copy( $fasta, $options{dir} );

$fasta = basename $fasta;
my $query_pssm_job = Rosetta::Job->new(
	dir          => $options{dir},
	args         => [
		basename($fasta),
		"--n_procs",  $options{n_procs},
		"--n_rounds", $options{n_rounds},
	],
	lockfile     => "query_prof.lock",
	executable   => "/work/tex/src/cm_scripts/bin/run-psiblast.pl",
	results_file => "$fasta.$options{n_rounds}.pssm",
);
if ( $options{make_profiles} ) {
	$query_pssm_job->run_with_message( "creating profile for $fasta" );
}

# extract template names, make profiles for them as well
mkdir $working_dir;
if ( ! -f assemble_path( $working_dir, basename $aln_file ) ) {
	#system( "cp -v $aln_file $working_dir" );
	copy( $aln_file, $working_dir );
}
my $rel_aln_file = basename $aln_file;

my $orig_dir = getcwd;
my @alns = @{ alignment::parse_alignments( $aln_file ) };
my %template_ids;
my %fasta_seqs;
TEMPLATE: foreach my $aln (@alns) {
	#print $aln->filt_string;
	my $id = join '', (
		lc( substr( $aln->template_name, 0, 4 ) ),
		uc( substr( $aln->template_name, 4, 1 ) )
	);

	my $template_pdb   = "$id.pdb";
	my $template_fasta = "$id.fasta";

	my $pdbid = substr( $id, 0, 4 );
	my $chain = substr( $id, 4, 1 );
	if ( ! -f "$working_dir/$template_pdb" ) {
		system( "cd $working_dir; get_pdb_new.py $pdbid $chain" );
	}
	system( "touch $working_dir/$template_fasta" );

	if ( ! -f "$working_dir/$template_pdb" ) {
		warn "Error: skipping $id because $template_pdb doesn't exist!\n";
		next TEMPLATE;
	}

	$template_ids{$id}++;

	my $ungapped_templ = $aln->get_template_alignment;
	$ungapped_templ =~ s/-//g;
	if ( !exists $fasta_seqs{$id} || length($ungapped_templ) > length($fasta_seqs{$id}) ) {
		for ( 1 .. $aln->get_template_start-1 ) {
			$ungapped_templ = 'X' . $ungapped_templ;
		}
		$fasta_seqs{$id} = $ungapped_templ;
	}
}

if ( $options{make_profiles} ) {
	foreach my $t_fasta ( glob( "$working_dir/*.fasta"  ) ) {
		if ( -z $t_fasta ) {
			my $id = basename( $t_fasta, '.fasta' );
			my $pdbid = substr( $id, 0, 4 );
			my $chain = substr( $id, 4, 1 );
			#system( "cd $working_dir; get_pdb_new.py $pdbid $chain;" );
			#system( "cd $working_dir; pdb2fasta.py $pdbid$chain.pdb > $t_fasta" );
			open FILE, ">$t_fasta" or die $!;
			print FILE "> $pdbid $chain fasta sequence", "\n";
			print FILE $fasta_seqs{$id}, "\n";
			close FILE or die $!;
			if ( -z $t_fasta ) {
				die "Error: $t_fasta is empty!\n";
			}
		}

		print "creating profile for ", $t_fasta, "\n";
		$t_fasta = basename $t_fasta;
		my $t_pssm_job = Rosetta::Job->new(
			dir => $working_dir,
			args => [
				$t_fasta,
				'--n_procs',  $options{n_procs},
				'--n_rounds', $options{n_rounds}
			],
			lockfile     => "$t_fasta.profile.lock",
			executable   => "/work/tex/src/cm_scripts/bin/run-psiblast.pl",
			results_file => "$t_fasta.$options{n_rounds}.psiblast",
		);
		$t_pssm_job->run( "creating profile for $t_fasta" );
	}
}

my @template_pdbs = map { abs_path($_) } glob( "$working_dir/*.pdb" );

my $rescore_job = Rosetta::Job->new(
	dir => $working_dir,
	args => [
		'-in:file:template_pdb', join ' ', @template_pdbs,
		'-in:file:alignment', $rel_aln_file,
		'-out:file:silent', $result_file,
		'-cm:seq_score ProfSim',
		'-cm:min_gap_open 2.0',
		'-cm:min_gap_extend 0.5',
		'-cm:aln_format grishin',
	],
	executable   => "/work/tex/src/mini/bin/score_aln.linuxgccrelease",
	lockfile     => "score_aln.lock",
	results_file => $result_file,
);
if ( $options{make_profiles} ) {
	my @pssms = map { abs_path($_) }
		glob( "$working_dir/*.$options{n_rounds}.pssm" );
	unshift @pssms, abs_path( assemble_path(
		$query_pssm_job->dir, $query_pssm_job->results_file
	) );
	$rescore_job->add_args( '-in:file:pssm', join ' ', @pssms );
}

if ( $options{native} ) {
	$rescore_job->add_args( '-in:file:native', abs_path($options{native}) );
}
$rescore_job->run_with_message( "rescoring alignments in $working_dir" );

# put this somewhere reasonable
sub read_alns {
	my $aln_file    = shift;
	my $aln_format  = shift;
	my $ev_map_file = shift;

	my @alns;
	if ( $aln_format eq 'hhsearch' ) {
		@alns = @{ hhsearch::parse_alignments( $aln_file ) };
	} elsif ( $aln_format eq 'grishin' ) {
		@alns = @{ alignment::parse_alignments( $aln_file ) };
	} elsif ( $aln_format eq 'blast' ) {
		@alns = @{ blast::parse_alignments( $aln_file ) };
	}

	print STDERR "ev_map_file = $ev_map_file\n";

	if ( $ev_map_file && -f $ev_map_file ) {
		open FILE, "<$ev_map_file" or die $!;
		my $header = <FILE>;
		my %ev_map;
		while ( my $line = <FILE> ) {
			chomp $line;
			my ($template,$e_value) = split /\s+/, $line;
			$ev_map{$template} = $e_value;
		}

		foreach my $aln (@alns) {
			my $template_name = join '', (
				lc( substr( $aln->get_template_name, 0, 4 ) ),
				uc( substr( $aln->get_template_name, 4, 1 ) )
			);
			$aln->template_name( $template_name );

			if ( exists $ev_map{$template_name} ) {
				#print "setting e-value of $template_name to ", $ev_map{$template_name}, "\n";
				$aln->e_value( $ev_map{$template_name} );
			}
		}
	}

	return \@alns;
}
