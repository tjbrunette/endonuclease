#!/usr/bin/perl
sub combine_scores
{
	my $pattern = $_[0];
	my $svmloc = $_[1];
	
	open(AVG,">$svmloc");
	my @files = `ls $pattern`;
	###############
	my @avg;my $file_count = 0;
	my $n_pre = 0;
	my $corrupted_files = 0;
	foreach $file (@files)
	{
		my $n = 0;
		chomp($file);
		my @avg2;
		open(FILE,$file);
		while($line = <FILE>){$avg2[$n] = $line;$n++;}
		close(FILE);
		if($n > $n_pre){$n_pre = $n;}
		if($n == $n_pre)
		{
			my $a = 0;while($avg2[$a]){$avg[$a] += $avg2[$a];$a++;}
			$file_count++;
		}
		else{$corrupted_files++;}
	}
	my $n = 0;
	while(exists $avg[$n])
	{
		my $avg_score = ($avg[$n]/$file_count);
		print AVG "$avg_score\n";
		$n++;
	}
	if($file_count == 0){print "FAIL: locating files to do calculations\n";}
	else{print "SUCCESS: Calculated average using [$file_count] files, with [$corrupted_files] corrupted files\n";}
	close(AVG);
	
}
if (scalar(@ARGV) == 0)
{
	print "==================================================================\n";
	print "                  RUN SVM: hetu's contact prediction\n"; 	
	print "==================================================================\n";
	print "Please enter varibles\n"; 
	print "------------------------------------------------------------------\n";
	print "-path	full path [REQUIRED]\n";
	print "-cpu	number of processors to use [Default = 1]\n";
	print "-type	which predictions to make: CA/CB/BOTH [Default = CB]\n";
	print "------------------------------------------------------------------\n";
	print "INSTRUCTIONS:\n";
	print " - Create a directory with name of your target\n";
	print " - Directory must contain 'seq.txt' with sequence in single line\n";
	print "===================================================================\n";
    	exit(0); 
}
while ($arg = shift())
{
	if ($arg =~ m/^-/)
	{
		if ($arg eq "-path") { $path = shift();next; }
		if ($arg eq "-cpu") { $cpu = shift();next; }
		if ($arg eq "-type") { $type = uc(shift());next; }
	}
}
unless(-d $path){die("ERROR: -path '$path' not found");}
if(substr($path,0,1) ne "/"){die("ERROR: -path '$path' is not a full path")}

if(!$cpu){$cpu = 1;}if(!$type){$type = "CB";}if($type ne "CA" and $type ne "CB" and $type ne "BOTH"){die("ERROR: -type '$type' invalid");}

if(substr($path,-1) eq "/"){$path = substr($path,0,-1);}

unless(-e "$path/seq.txt"){die("ERROR: failed to locate $path/seq.txt");}
my $target = $path; $target =~ s{.*/}{};

my $pth_to_dir = $path; my $targetname = $target; my $num_procs = $cpu;
my $tartest = "$path/$target";
unless(	-e "$path/blast.out" and -e "$tartest.dat" and -e "$tartest.fasta" and -e "$tartest.mat3" and -e "$tartest.out" and -e "$tartest.ss" and -e "$tartest.time_exp.txt"
	and -e "$tartest.blast" and -e "$tartest.exp.dat" and -e "$tartest.horiz" and -e "$tartest.neu" and -e "$tartest\_pssm.txt" and -e "$tartest.ss2")
{
	print "running blast/psipred/solvent prediction/\n";
	system("/work/krypton/make_cst/SVMSEQ_onlyrunpssmsolvexp.pl $pth_to_dir $targetname");
	system("/work/krypton/make_cst/exp_clean.pl /work/hetu/bin/SVMSEQ_source/library/ $pth_to_dir $targetname");
}
unless(	-e "$tartest\_features_0_myfeatssuffix2_scl_1_1" and -e "$tartest\_features_0_myfeatssuffix2_edges" and
	-e "$tartest\_features_1_myfeatssuffix2_scl_1_1" and -e "$tartest\_features_1_myfeatssuffix2_edges" and
	-e "$tartest\_features_2_myfeatssuffix2_scl_1_1" and -e "$tartest\_features_2_myfeatssuffix2_edges")
{
	print "writing feature files\n";
	system("/work/hetu/src/contact_pred/gen_myfeats.sh $pth_to_dir");
	
	print "scaling feature file (to have bounded values) before calling svm\n";
	for $f (0..2)
	{
		system("/work/hetu//bin/libsvm-3.1/svm-scale -r /work/hetu/data/contact_pred/pub_models/pisces_features_$f\_myfeatssuffix2.range_1_1 $pth_to_dir/$targetname\_features_$f\_myfeatssuffix2 > $pth_to_dir/$targetname\_features_$f\_myfeatssuffix2_scl_1_1");
	  	unlink("$pth_to_dir/$targetname\_features_$f\_myfeatssuffix2");
	}
}
#run svm predictions
print "Populating LIST of jobs to run for each seq sep\n";
for $f (0..2)
{
	my $edge_count = `wc -l $tartest\_features_$f\_myfeatssuffix2_edges`;chomp($edge_count);
	print "calling svmg for seq sep $f\n";
	my @models;
	if($type eq "BOTH"){@models = `ls /work/hetu/data/contact_pred/pub_models/pisces_vall_features_$f*model`;}
  	elsif($type eq "CA"){@models = `ls /work/hetu/data/contact_pred/pub_models/pisces_vall_features_$f*CA*model`;}
  	elsif($type eq "CB"){@models = `ls /work/hetu/data/contact_pred/pub_models/pisces_vall_features_$f*CB*model`;}
  	
  	my $featf = "$pth_to_dir/$targetname\_features_$f\_myfeatssuffix2_scl_1_1";

	open(LIST,">$pth_to_dir/run_$f\_list");
	foreach $model (@models)
	{
		chomp($model);
		my $suffix = $model;
		$suffix =~ s{.*/}{};
		$suffix =~ s/pisces_vall_features_$f\_myfeatssuffix2//g;
		if(-e "$featf$suffix\_preds") #if preds exists, but does not have correct # edges, delete.
		{
			my $test = `wc -l $featf$suffix\_preds`;chomp($test);
			if($test != $edge_count){unlink("$featf$suffix\_preds");unlink("$featf$suffix\_out");}
		}
		unless(-e "$featf$suffix\_preds") #unless preds already exists, add to LIST
		{
			print LIST "/work/hetu/bin/svm_light/svm_classify $featf $model $featf$suffix\_preds > $featf$suffix\_out\n";
		}
	}
	close(LIST);
}
print "Running svm classify for all seq sep\n";
print "Warning! this can take a very long time\n";
system("cat $pth_to_dir/run_0_list $pth_to_dir/run_1_list $pth_to_dir/run_2_list | /work/krypton/bin/parallel -j $num_procs");
print "Averaging scores\n";
for $f (0..2)
{
	my $featf = "$pth_to_dir/$targetname\_features_$f\_myfeatssuffix2_scl_1_1";
	if($type eq "CA" or $type eq "BOTH")
	{
		combine_scores("$featf\_truth_CA_6.sampleneg_ratio4_scl_1_1_100k_*_j1_t1_model_preds","$featf\_truth_CA_6.sampleneg_ratio4_scl_1_1_100k_all_j1_t1_avg_model_preds");
		combine_scores("$featf\_truth_CA_7.sampleneg_ratio4_scl_1_1_100k_*_j1_t1_model_preds","$featf\_truth_CA_7.sampleneg_ratio4_scl_1_1_100k_all_j1_t1_avg_model_preds");
	}
	if($type eq "CB" or $type eq "BOTH")
	{
		combine_scores("$featf\_truth_CB_8.sampleneg_ratio4_scl_1_1_100k_*_j1_t1_model_preds","$featf\_truth_CB_8.sampleneg_ratio4_scl_1_1_100k_all_j1_t1_avg_model_preds");
	}
}
print "Generating Sergey's Constraint files\n";
if($type eq "CA" or $type eq "BOTH")
{
	system("perl /work/krypton/make_cst/make_CA_cst_2012-02-03.perl $path");
	system("perl /work/krypton/make_cst/make_CA6_cst_2012-02-14.perl $path");
	system("perl /work/krypton/make_cst/make_CA7_cst_2012-02-14.perl $path");
}
if($type eq "CB" or $type eq "BOTH")
{
	system("perl /work/krypton/make_cst/make_CB8_cst_2012-02-14.perl $path");
}
