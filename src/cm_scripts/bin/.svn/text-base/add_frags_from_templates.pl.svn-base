#!/usr/bin/perl

use strict;
use warnings;

use lib '/work/tex/src/cm_scripts/perl_lib';
use List::Util qw/ max /;
use Getopt::Long;
use Data::Dumper::Simple;
use Rosetta::Template;
use Rosetta::align_util qw/ read_alns /;

my %options;
$options{aln_fn}            = "T0538/alignment/alignment.filt";
$options{mini_compiler}     = 'gcc';
$options{db_path}           = "/work/tex/src/rosetta/rosetta_database";
$options{mini_path}         = "/work/tex/src/rosetta/rosetta_source";
$options{mini_compile_mode} = 'release';
$options{frag_fn}           = [];
$options{max_frags}         = 200;

&GetOptions(
	\%options,
	"aln_fn=s",
	"mini_compiler=s",
	"db_path=s",
	"mini_path=s",
	"mini_compile_mode=s",
	"aln_fn=s",
	"frag_fn=s",
	"max_frags=i",
);

my @alns = read_alns($options{aln_fn},'grishin');

foreach my $ff ( @{ $options{frag_fn} } ) {
	my $len = get_fragment_file_len($ff);
	#print "len($ff) = $len\n";

	my %template_frag_dat;
	ALN: foreach my $aln (@alns) {
		my $template_id = substr($aln->get_template_name,0,5);
		my $pdbid = substr($template_id,0,4);
		my $chain = substr($template_id,4,1);
		my $pdb_fn = "$pdbid$chain.pdb";
		if ( ! -f $pdb_fn ) {
			system( "get_pdb.py $pdbid $chain" );
		}

		if ( ! -f $pdb_fn ) {
			warn "Didn't get $pdbid$chain.pdb!\n";
			next ALN;
		}
		if ( !-f "ideal/$pdbid$chain\_0001.pdb.torsions" ) {
			Rosetta::Template::make_vall_lines($pdb_fn,\%options);
		}

		my %torsions = %{ read_torsions("ideal/$pdbid$chain\_0001.pdb.torsions") };
		my $map      = $aln->map_query_template;
		my $max_res  = max keys %$map;

		for my $resi ( 1 .. $max_res ) {
			my $add_frag = 1;
			for my $pos ( 0 .. $len-1 ) {
				my $idx = $resi + $pos;
				if ( exists $map->{$idx} && $map->{$idx} eq '-' ) {
					$add_frag = 0;
				}
			}
			if ( $add_frag ) {
				# grab the analogous torsions from the template
				my $frag = [];
				foreach my $pos ( 0 .. $len-1 ) {
					my $q_idx = $resi + $pos;
					my $t_idx = $map->{$q_idx};

					my $frag_line = {
						pdbid  => $pdbid,
						chain  => $chain,
						t_resi => $t_idx,
						t_aa   => $torsions{$t_idx}{aa},
						t_ss   => $torsions{$t_idx}{ss},
						phi    => $torsions{$t_idx}{phi},
						psi    => $torsions{$t_idx}{psi},
						omega  => $torsions{$t_idx}{omega},
					};

					push @$frag, $frag_line;
				}
				push @{ $template_frag_dat{$resi} }, $frag;
			}
		} # for $resi
	} # alns

	# open the fragment file
	open FILE, "<$ff" or die $!;
	my $current_pos = 0;
	my $frag_count  = 0;

	open OUT, ">$ff.hom" or die $!;
	while ( my $line = <FILE> ) {
		chomp $line;
		if ( $line =~ /position:\s+(\d+)\s+neighbors:\s+(\d+)/ ) {
			$current_pos = $1;
			my $nn = $2;
			$frag_count = 0;
			$line =~ s/(neighbors:\s+)\d+/$1$options{max_frags}/g;
			print OUT $line, "\n\n";
		} elsif ( $line =~ / ([\d\w]{4})/ && !exists $template_frag_dat{$current_pos} ) {
			# fill in the rest with the top of the current frags
			print OUT $line, "\n";
			STEAL: while ( my $steal_line = <FILE> ) {
				if ( $steal_line =~ /^\s*$/ ) {
					$frag_count++;
				}
				if ( $frag_count >= $options{max_frags} ) {
					last STEAL;
				}
				if ( $frag_count <= $options{max_frags} ) {
					#print "stealing frag $frag_count\n";
					print OUT $steal_line;
				}
			}
			print OUT "\n";
		} elsif ( $line =~ / ([\d\w]{4})/ && scalar(@{$template_frag_dat{$current_pos}}) ) {
			# print out all of the homolog frags here
			while ( my $frag = shift @{ $template_frag_dat{$current_pos} } ) {
				my $lines = frag_to_lines($frag);
				print OUT $lines, "\n";	
				$frag_count++;
			}
			print "added $frag_count from homologs frags at position $current_pos.\n";

			# fill in the rest with the top of the current frags
			print OUT $line, "\n";
			STEAL: while ( my $steal_line = <FILE> ) {
				if ( $steal_line =~ /^\s*$/ ) {
					$frag_count++;
				}
				if ( $frag_count >= $options{max_frags} ) {
					last STEAL;
				}
				if ( $frag_count <= $options{max_frags} ) {
					#print "stealing frag $frag_count\n";
					print OUT $steal_line;
				}
			}

			print OUT "\n";
		}
	}
	close OUT  or die $!;
	close FILE or die $!;
}

sub frag_to_lines {
	my $frag = shift;

	my $lines = '';
	foreach my $d ( @$frag ) {
		my $line = ' ' . $d->{pdbid} . ' ' . $d->{chain} . sprintf( "%6d", $d->{t_resi} ) . ' ';
		$line .= $d->{t_aa} . ' ' . $d->{t_ss} . ' ';
		foreach my $ang ( qw/ phi psi omega / ) {
			$d->{$ang} = sprintf( "%8.3f", $d->{$ang} );
		}
		$line .= join ' ', ( $d->{phi}, $d->{psi}, $d->{omega} );
		$lines .= $line . "\n";
	}
	return $lines;
}

sub get_fragment_file_len {
	my $fn = shift;

	open FILE, "<$fn" or die "Error opening file $fn ($!)";
	my $len = 0;
	LINE: while ( my $line = <FILE> ) {
		if ( $line =~ / ([\d\w]{4}) / ) {
			$len++;
		}

		if ( $line =~ /^\s*$/ && $len > 0 ) {
			last LINE;
		}
	}
	close FILE or die $!;

	return $len;
}

sub read_torsions {
	my $fn = shift;

	open ANGLES, "<$fn" or die $!;
	<ANGLES>;
	my %torsions;
	while ( my $line = <ANGLES> ) {
		chomp $line;
		$line =~ s/^\s+//g;
		if ( $line =~ /^\d+\s+\w\s+\w\s+[\-\d\.]+/ ) {
			my ($idx,$aa,$ss,$phi,$psi,$omega,$CA_x,$CA_y,$CA_z,$chi1) = split /\s+/, $line;
			$torsions{$idx} = {
				aa    => $aa,
				resi  => $idx,
				ss    => $ss,
				phi   => $phi,
				psi   => $psi,
				omega => $omega,
				CA_x  => $CA_x,
				CA_y  => $CA_y,
				CA_z  => $CA_z,
				chi1  => $chi1,
			};
		} else {
			#warn "didn't match line $line\n";
		}
	}
	close ANGLES or die $!;
	return \%torsions;
}
