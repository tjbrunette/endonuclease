#! /usr/bin/env python2.7
from os import system, popen, remove
from os.path import exists, basename
from sys import stderr, stdout
from multiprocessing import Pool
from argparse import ArgumentParser


def get_pdb( pdb ):
    pdbdir    = "/work/wangyr/scripts/cm_util/pdb_matchback/PDBs"
    if not exists( pdbdir + "/"+ pdb[1:3] + "/" +pdb ):
        cmd = "/work/wangyr/scripts/cm_util/pdb_matchback/get_pdb_new.py %s %s 2> /dev/null" %( pdb[:4], pdb[4] )
        system( cmd )
        if not exists( pdb ):
            return 0
        else:
            system("cp %s %s/%s" %( pdb, pdbdir, pdb[1:3]))
            return pdb
    else:
        return pdbdir + "/" + pdb[1:3] + "/" + pdb[:5] + ".pdb"


def get_pdb_list_from_nrtable( nrtable ):
    pdb_list = []
    for line in open( nrtable, "r").readlines():
        if line.startswith("#"): continue
        pdbid    = line.split()[0].lower()
        chain    = line.split()[1].upper()
        pdb      = pdbid + chain + ".pdb"
        pdb_list.append( pdb )

    return pdb_list


def run_tmalign( arg ):
    pdb       = arg[0]
    model     = arg[1]
    output_fn = arg[2]

    if not exists( pdb ):
        pdb = get_pdb( basename( pdb ))
        if not pdb:
            stderr.write("ERROR: not able to get %s ?\n" %(arg[0])); return 0

    cmd = '~wangyr/bin/TMalign %s %s' % ( pdb, model  )
    file_handling = popen(cmd)
    line = file_handling.readline()

    if not line:
        stderr.write("ERROR: not able to run TMalign %s %s ( empty files )?\n" %(pdb, model)); return 0

    while line:
        if "Chain 2:" in line:
            #total_nres = float( line.split()[3] )
            total_nres = line.split()[3]

        if "TM-score=" in line:
            aligned_nres = int( line.split()[2][:-1] )
            TM_score     = float( line.split()[5][9:-1] )
            RMSD         = float( line.split()[4][:-1])

        line = file_handling.readline()

    results_line = "%s -vs- %s  aligned_res: %3s / %3s  TMscore: %5.4f  RMSD: %3.2f \n" %( basename(pdb), basename(model), aligned_nres, total_nres, TM_score, RMSD )
    if exists( basename(pdb) ) and basename(pdb) != basename(model):
        remove( basename(pdb) ) 

    #stderr.write(results_line)
    output = open( output_fn, "a")
    output.write( results_line )
    output.close()

    return results_line



if __name__=="__main__":
    parser = ArgumentParser()
    parser.add_argument("-m", "--models", nargs="+", required=True, help="model you would like to look back!")
    parser.add_argument("--casp9", action="store_true", help="pdb set filtered by date 042510!")
    parser.add_argument("--latest", action="store_true", help="the latest pdb set!")
    parser.add_argument("--n_processors", type=int, default=20, help="numbers of CPUs you are going to use, default=20")
    parser.add_argument("--output_fn", default="results.txt", help="output file name")
    options = parser.parse_args()

    if options.latest:
        if exists("nrpdb.latest"): 
            remove("nrpdb.latest")
        stdout.write("get pdb table from NCBI:  \n")
        system("wget ftp://ftp.ncbi.nih.gov/mmdb/nrtable/nrpdb.latest")
        nrtable = "nrpdb.latest"
    elif options.casp9:
        nrtable = "/work/wangyr/scripts/cm_util/pdb_matchback/nrtable/nrpdb.042510"
    else:
        stderr.write("ERROR: you should at least specify a list to search with: --latest or --casp9 .\n"); exit()

    if exists( options.output_fn ):
        remove( options.output_fn )
    cmd_list = [( pdb, model, options.output_fn ) for model in options.models for pdb in get_pdb_list_from_nrtable( nrtable ) ]

    myPool    = Pool( processes = options.n_processors )
    myResults = myPool.map_async( run_tmalign, cmd_list )
    myResults.get() 

